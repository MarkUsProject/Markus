describe Course do
  let(:course) { create :course }
  context 'validations' do
    it { is_expected.to validate_presence_of(:name) }
    it { expect(course).to validate_uniqueness_of(:name) }
    it { is_expected.not_to allow_value('Mike Ooh').for(:name) }
    it { is_expected.not_to allow_value('A!a.sa').for(:name) }
    it { is_expected.to allow_value('Ads_-hb').for(:name) }
    it { is_expected.to allow_value('-22125-k1lj42_').for(:name) }
    it { is_expected.to allow_value('CSC108 2021 Fall').for(:display_name) }
    it { is_expected.to allow_value('CSC108, 2021 Fall').for(:display_name) }
    it { is_expected.to allow_value('CSC108!.2021 Fall').for(:display_name) }
    it { is_expected.to allow_value('CSC108-2021-Fall').for(:display_name) }
    it { is_expected.to have_many(:assignments) }
    it { is_expected.to have_many(:grade_entry_forms) }
    it { is_expected.to have_many(:sections) }
    it { is_expected.to have_many(:groups) }
    it { is_expected.to allow_value(true).for(:is_hidden) }
    it { is_expected.to allow_value(false).for(:is_hidden) }
    it { is_expected.not_to allow_value(nil).for(:is_hidden) }
    it { is_expected.to validate_numericality_of(:max_file_size).is_greater_than_or_equal_to(0) }
  end

  context 'callbacks' do
    describe '#update_repo_max_file_size' do
      # a course should be the only thing created here, if that ever changes, make sure the db is cleaned properly
      after { course.destroy! }
      shared_examples 'when not using git repos' do
        before { allow(Settings.repository).to receive(:type).and_return('mem') }
        it 'should not schedule a background job' do
          expect(UpdateRepoMaxFileSizeJob).not_to receive(:perform_later).with(course.id)
          subject
        end
      end
      shared_context 'git repos' do
        before do
          allow(Settings.repository).to receive(:type).and_return('git')
          allow(GitRepository).to receive(:purge_all)
        end
        after(:each) { FileUtils.rm_r(Dir.glob(File.join(Repository::ROOT_DIR, '*'))) }
      end
      context 'after creation' do
        subject { course }
        context 'when using git repos' do
          include_context 'git repos'
          it 'should schedule a background job' do
            expect(UpdateRepoMaxFileSizeJob).to receive(:perform_later)
            subject
          end
        end
        include_examples 'when not using git repos'
      end
      context 'after save to max_file_size' do
        before { course }
        subject { course.update! max_file_size: course.max_file_size + 10_000 }
        context 'when using git repos' do
          include_context 'git repos'
          after { FileUtils.rm_r(Dir.glob(File.join(Repository::ROOT_DIR, '*'))) }
          it 'should schedule a background job' do
            expect(UpdateRepoMaxFileSizeJob).to receive(:perform_later).with(course.id)
            subject
          end
        end
        include_examples 'when not using git repos'
      end
      context 'after save to something else' do
        before { course }
        subject { course.update! display_name: "#{course.display_name}abc" }
        context 'when using git repos' do
          include_context 'git repos'
          it 'should not schedule a background job' do
            expect(UpdateRepoMaxFileSizeJob).not_to receive(:perform_later).with(course.id)
            subject
          end
        end
        include_examples 'when not using git repos'
      end
    end
  end

  def create_assignment_csv_string(a)
    # returns a csv formatted string for an assignment where each attribute
    # specified by Assignment::DEFAULT_FIELDS appears in the same order as initialized
    # and is comma separated.

    # a is an assignment stored in the database

    "#{a.short_identifier},#{a.description},#{a.due_date},#{a.message}," \
      "#{a.group_min},#{a.group_max},#{a.tokens_per_period},#{a.allow_web_submits}," \
      "#{a.student_form_groups},#{a.remark_due_date},#{a.remark_message}," \
      "#{a.assign_graders_to_criteria},#{a.enable_test},#{a.enable_student_tests}," \
      "#{a.allow_remarks},#{a.display_grader_names_to_students},#{a.display_median_to_students}," \
      "#{a.group_name_autogenerated},#{a.is_hidden},#{a.vcs_submit},#{a.has_peer_review}\n"
  end

  def create_assignment_symbol_to_value_map(a)
    # returns a mapping of attribute symbols present in Assignment::DEFAULT_FIELDS to
    # their associated value in the variable a where a is an assignment.
    { short_identifier: a.short_identifier,
      description: a.description,
      due_date: a.due_date,
      message: a.message,
      group_min: a.group_min,
      group_max: a.group_max,
      tokens_per_period: a.tokens_per_period,
      allow_web_submits: a.allow_web_submits,
      student_form_groups: a.student_form_groups,
      remark_due_date: a.remark_due_date,
      remark_message: a.remark_message,
      assign_graders_to_criteria: a.assign_graders_to_criteria,
      enable_test: a.enable_test,
      enable_student_tests: a.enable_student_tests,
      allow_remarks: a.allow_remarks,
      display_grader_names_to_students: a.display_grader_names_to_students,
      display_median_to_students: a.display_median_to_students,
      group_name_autogenerated: a.group_name_autogenerated,
      is_hidden: a.is_hidden,
      vcs_submit: a.vcs_submit,
      has_peer_review: a.has_peer_review }
  end

  describe '#get_assignment_list' do
    context 'when file_format = yml' do
      context 'when there are no assignments in the course' do
        it 'should return a yml representation of a course with no assignments' do
          result = course.get_assignment_list('yml')
          expected = { assignments: [] }.to_yaml
          expect(result).to eq(expected)
        end
      end
      context 'when the course has a single assignment' do
        # NOTE: the created assignment must be reloaded as the value for assignment1.due_date stored in the database is
        # less precise than that stored by ruby.
        let!(:assignment1) { (create :assignment, due_date: 5.days.ago, course: course).reload }
        it 'should return a yml representation of a assignments in a course with a single assignment' do
          result = course.get_assignment_list('yml')
          expected = { assignments: [create_assignment_symbol_to_value_map(assignment1)] }.to_yaml
          expect(result).to eq(expected)
        end
      end
      context 'when the course has multiple assignments' do
        let!(:assignment1) { (create :assignment, due_date: 5.days.ago, course: course).reload }
        let!(:assignment2) { (create :assignment, due_date: 1.day.ago, course: course).reload }
        let!(:assignment3) { (create :assignment, due_date: 8.days.from_now, course: course).reload }
        it 'should return a yml representation of a assignments in a course with a multiple assignments' do
          result = course.get_assignment_list('yml')
          expected = { assignments: [create_assignment_symbol_to_value_map(assignment1),
                                     create_assignment_symbol_to_value_map(assignment2),
                                     create_assignment_symbol_to_value_map(assignment3)] }.to_yaml
          expect(result).to eq(expected)
        end
      end
    end
    context 'when file_format = csv' do
      context 'when there are no assignments in the course' do
        it 'should return an empty string' do
          result = course.get_assignment_list('csv')
          expect(result).to eq('')
        end
      end
      context 'when the course has a single assignment' do
        let!(:assignment1) { create :assignment, due_date: 5.days.ago, course: course }
        it 'should return a string representation of the assignment1 object' do
          result = course.get_assignment_list('csv').to_s
          expected_result = create_assignment_csv_string(assignment1)
          puts result
          puts expected_result
          expect(result).to eq(expected_result)
        end
      end
      context 'when the course has multiple assignments' do
        let!(:assignment1) { create :assignment, due_date: 5.days.ago, course: course }
        let!(:assignment2) { create :assignment, due_date: 1.day.ago, course: course }
        let!(:assignment3) { create :assignment, due_date: 8.days.from_now, course: course }
        it 'should return a csv string representation of the assignment 1, 2 and 3 objects' do
          result = course.get_assignment_list('csv').to_s
          expected_result = ''
          [assignment1, assignment2, assignment3].each do |assignment|
            expected_result += create_assignment_csv_string(assignment)
          end
          expect(result).to eq(expected_result)
        end
      end
    end
  end

  describe '#upload_assignment_list' # TODO
  describe '#get_required_files' # TODO
  describe '#update_autotest_url' do
    before do
      allow_any_instance_of(AutotestSetting).to receive(:register).and_return(1)
      allow_any_instance_of(AutotestSetting).to receive(:get_schema).and_return('{}')
    end
    let(:url) { 'http://example.com' }
    context 'when no autotest setting already exists for that url' do
      it 'should create a new autotest setting' do
        expect { course.update_autotest_url(url) }.to(change { AutotestSetting.where(url: url).count }.from(0).to(1))
      end
      it 'should associate the new setting with the course' do
        course.update_autotest_url(url)
        expect(course.reload.autotest_setting.url).to eq url
      end
      context 'when assignments exist for the course' do
        before do
          create_list :assignment, 3, course: course,
                                      assignment_properties_attributes: { remote_autotest_settings_id: 1 }
        end
        it 'should reset the remote_autotest_settings_id for all assignments' do
          course.update_autotest_url(url)
          expect(course.assignments.pluck(:remote_autotest_settings_id).compact).to be_empty
        end
      end
    end
    context 'when an autotest setting exists for that url' do
      before { course.update! autotest_setting_id: create(:autotest_setting, url: url).id }
      it 'should not create a new autotest setting' do
        expect { course.update_autotest_url(url) }.not_to(change { AutotestSetting.where(url: url).count })
      end
      it 'should not change the association' do
        course.update_autotest_url(url)
        expect(course.reload.autotest_setting.url).to eq url
      end
      context 'when assignments exist for the course' do
        before do
          create_list :assignment, 3, course: course,
                                      assignment_properties_attributes: { remote_autotest_settings_id: 1 }
        end
        it 'should not reset the remote_autotest_settings_id for all assignments' do
          course.update_autotest_url(url)
          expect(course.assignments.pluck(:remote_autotest_settings_id).to_set).to contain_exactly(1)
        end
      end
      context 'when the autotest setting is changed' do
        it 'should associate the new setting with the course' do
          course.update_autotest_url('http://example.com/other')
          expect(course.reload.autotest_setting.url).to eq 'http://example.com/other'
        end
        context 'when assignments exist for the course' do
          before do
            create_list :assignment, 3, course: course,
                                        assignment_properties_attributes: { remote_autotest_settings_id: 1 }
          end
          it 'should reset the remote_autotest_settings_id for all assignments' do
            course.update_autotest_url('http://example.com/other')
            expect(course.assignments.pluck(:remote_autotest_settings_id).compact).to be_empty
          end
        end
      end
    end
  end

  describe '#get_current_assignment' do
    context 'when no assignments are found' do
      it 'returns nil' do
        result = course.get_current_assignment
        expect(result).to be_nil
      end
    end

    context 'when one assignment is found' do
      let!(:assignment1) { create :assignment, due_date: 5.days.ago, course: course }

      it 'returns the only assignment' do
        result = course.get_current_assignment
        expect(result).to eq(assignment1)
      end
    end

    context 'when more than one assignment is found' do
      context 'when there is an assignment due in 3 days' do
        let!(:assignment1) { create :assignment, due_date: 5.days.ago, course: course }
        let!(:assignment2) { create :assignment, due_date: 3.days.from_now, course: course }

        it 'returns the assignment due in 3 days' do
          result = course.get_current_assignment
          # should return assignment 2
          expect(result).to eq(assignment2)
        end
      end

      context 'when the next assignment is due in more than 3 days' do
        let!(:assignment1) { create :assignment, due_date: 5.days.ago, course: course }
        let!(:assignment2) { create :assignment, due_date: 1.day.ago, course: course }
        let!(:assignment3) { create :assignment, due_date: 8.days.from_now, course: course }

        it 'returns the assignment that was most recently due' do
          result = course.get_current_assignment
          # should return assignment 2
          expect(result).to eq(assignment2)
        end
      end

      context 'when all assignments are due in more than 3 days' do
        let!(:assignment1) { create :assignment, due_date: 5.days.from_now, course: course }
        let!(:assignment2) { create :assignment, due_date: 12.days.from_now, course: course }
        let!(:assignment3) { create :assignment, due_date: 19.days.from_now, course: course }

        it 'returns the assignment that is due first' do
          result = course.get_current_assignment
          # should return assignment 1
          expect(result).to eq(assignment1)
        end
      end

      context 'when all assignments are past the due date' do
        let!(:assignment1) { create :assignment, due_date: 5.days.ago, course: course }
        let!(:assignment2) { create :assignment, due_date: 12.days.ago, course: course }
        let!(:assignment3) { create :assignment, due_date: 19.days.ago, course: course }

        it 'returns the assignment that was due most recently' do
          result = course.get_current_assignment
          # should return assignment 1
          expect(result).to eq(assignment1)
        end
      end
    end
  end

  describe '#export_student_data_csv' do
    context 'when there are no students in the course' do
      it 'returns empty string' do
        result = course.export_student_data_csv
        expect(result).to eq('')
      end
    end

    context 'when there is a student in the course' do
      let!(:user1) { create :end_user }
      let!(:student1) { create :student, user: user1, course: course }
      it 'returns the data of the student' do
        result = course.export_student_data_csv
        expect(result).to eq("#{user1.user_name},#{user1.last_name},#{user1.first_name},,,#{user1.email}\n")
      end
    end

    context 'where there are multiple students in the course' do
      let!(:user1) { create :end_user }
      let!(:user2) { create :end_user }
      let!(:student1) { create :student, user: user1, course: course }
      let!(:student2) { create :student, user: user2, course: course }
      it 'returns the data of the students' do
        result = course.export_student_data_csv

        student1_data = "#{user1.user_name},#{user1.last_name},#{user1.first_name},,,#{user1.email}\n"
        student2_data = "#{user2.user_name},#{user2.last_name},#{user2.first_name},,,#{user2.email}\n"
        if user1.user_name <= user2.user_name
          expected = student1_data + student2_data
        else
          expected = student2_data + student1_data
        end
        expect(result).to eq(expected)
      end
    end
  end

  describe '#export_student_data_yml' do
    context 'where there are no students in the course' do
      it 'returns empty yaml object' do
        result = course.export_student_data_yml
        expect(result).to eq([].to_yaml)
      end
    end

    context 'where there is a student in the course' do
      let!(:user1) { create :end_user }
      let!(:student1) { create :student, user: user1, course: course }
      it 'returns the data of the student' do
        result = course.export_student_data_yml
        expected = [{ user_name: user1.user_name,
                      last_name: user1.last_name,
                      first_name: user1.first_name,
                      email: user1.email,
                      id_number: nil,
                      section_name: nil }]
        expect(result).to eq(expected.to_yaml)
      end
    end

    context 'when there are multiple students in the course' do
      let!(:user1) { create :end_user }
      let!(:user2) { create :end_user }
      let!(:student1) { create :student, user: user1, course: course }
      let!(:student2) { create :student, user: user2, course: course }
      it 'returns the data of the students' do
        result = course.export_student_data_yml
        expected = []

        student1_data = {
          user_name: user1.user_name,
          last_name: user1.last_name,
          first_name: user1.first_name,
          email: user1.email,
          id_number: nil,
          section_name: nil
        }

        student2_data = {
          user_name: user2.user_name,
          last_name: user2.last_name,
          first_name: user2.first_name,
          email: user2.email,
          id_number: nil,
          section_name: nil
        }

        if user1.user_name <= user2.user_name
          expected.push(student1_data)
          expected.push(student2_data)
        else
          expected.push(student2_data)
          expected.push(student1_data)
        end
        expect(result).to eq(expected.to_yaml)
      end
    end
  end
end
