require 'spec_helper'

describe Group do

  it { is_expected.to validate_presence_of(:group_name) }
  it { is_expected.to validate_uniqueness_of(:group_name) }
  it { is_expected.to ensure_length_of(:group_name).is_at_most(30) }

  describe '#set_repo_name' do
    # The tests below are checking for a method that is called when
    # the group is initially created, so it is not explicitly called here.
    context 'when repository name is specified' do
      let(:group) { create(:group, repo_name: 'g2markus') }

      it 'sets repo_name to specified repository name' do
        expect(group.repo_name).to eq 'g2markus'
      end
    end

    context 'when repository name is not specified' do
      let(:group) { create(:group) }

      it 'sets repo_name to autogenerated repository name' do
        expect(group.repo_name).to start_with 'group_'
      end
    end
  end

  describe '#repository_name' do
    let(:group) { create(:group, repo_name: 'g2markus') }

    it 'returns the group\'s repository name' do
      expect(group.repository_name).to eq 'g2markus'
    end
  end

  describe '#get_autogenerated_group_name' do
    let(:group) { create(:group) }

    it 'returns autogenerated group names' do
      expect(group.get_autogenerated_group_name).to start_with('group_')
    end
  end

  describe '#grouping_for_assignment' do
    let!(:grouping) { create(:grouping) }

    it 'returns the grouping for the specified assignment' do
      group = grouping.group
      assignment = grouping.assignment
      expect(group.grouping_for_assignment(assignment.id)).to eq grouping
    end
  end

  describe '#repository_external_access_url' do
    let(:group) { create(:group) }

    it 'returns the repository URL' do
      expect(group.repository_external_access_url).to end_with(group.repo_name)
    end
  end

  describe '#repository_admin?' do
    context 'with administrator rights' do
      let(:group) { create(:group) }

      it 'returns true' do
        expect(group.repository_admin?).to be_truthy
      end
    end
  end

  describe '#repository_config' do
    let(:group) { create(:group) }

    it 'returns repository configuration' do
      is_repo_admin = MarkusConfigurator.markus_config_repository_admin?
      repo_perm = MarkusConfigurator.markus_config_repository_permission_file
      repo_storage = MarkusConfigurator.markus_config_repository_storage

      conf = group.repository_config
      expect(conf['IS_REPOSITORY_ADMIN']).to eq(is_repo_admin)
      expect(conf['REPOSITORY_PERMISSION_FILE']).to eq(repo_perm)
      expect(conf['REPOSITORY_STORAGE']).to eq(repo_storage)
    end
  end

  describe '#build_repository' do
    let(:group) { create(:group) }

    it 'returns true' do
      expect(group.build_repository).to be_truthy
    end
  end

  describe '#repo' do
    let(:group) { create(:group) }

    it 'returns a repository object' do
      expect(group.repo).to be_truthy
    end
  end

  describe '#access_repo' do
    context 'when repository exists' do
      let(:group) { create(:group) }

      it 'allows access to its repository' do
        group.access_repo do |repo|
          expect(repo).to be_truthy
          expect(repo.closed?).to be_falsey
        end
      end
    end

    context 'when repository is closed' do
      let(:group) { create(:group) }

      it 'raises an error' do
        group.repo do |repo|
          repo.close
          expect(group.access_repo).to raise_error
        end
      end
    end
  end
end
