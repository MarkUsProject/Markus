require File.expand_path(File.join(File.dirname(__FILE__), 'authenticated_controller_test'))
require File.expand_path(File.join(File.dirname(__FILE__), '..', 'blueprints', 'blueprints'))
require File.expand_path(File.join(File.dirname(__FILE__), '..', 'blueprints', 'helper'))

require 'shoulda'
require 'machinist'
require 'mocha/setup'
require 'time-warp'

class AssignmentsControllerTest < AuthenticatedControllerTest

  def setup
    @controller = AssignmentsController.new
    @request = ActionController::TestRequest.new
    @response = ActionController::TestResponse.new
  end

  def teardown
    destroy_repos
  end

  context 'An admin' do
    setup do
      @admin = Admin.make
    end

    should 'be able to get new' do
      get_as @admin, :new
      assert_not_nil assigns :assignment
      assert_not_nil assigns :assignments
      assert_response :success
    end

    context 'creating a new assignment' do
      setup do
        @short_identifier = Sham.short_identifier
        @attributes = { 'commit' => 'Submit',
                        'assignment' => {'student_form_groups' => '0',
                                        'group_name_autogenerated' => '0',
                                        'short_identifier' => @short_identifier,
                                        'repository_folder' => "/#{@short_identifier}",
                                        'group_max' =>'1',
                                        'due_date' => 2.days.from_now,
                                        'display_grader_names_to_students' =>'false',
                                        'allow_web_submits' =>'true',
                                        'description' => Sham.description,
                                        'allow_remarks' =>'true',
                                        'submission_rule_attributes' =>
                                          { 'type' =>'NoLateSubmissionRule' },
                                        'group_min' =>'1',
                                        'marking_scheme_type' =>'rubric'
                       }
        }
      end

      should 'have created the assignment and redirected properly' do
        post_as @admin, :create, @attributes
        new_assignment = Assignment.find_by_short_identifier(@short_identifier)
        assert_not_nil new_assignment
        assert redirect_to(action: 'edit', id: new_assignment)
      end

      should 'have an assignment stat object associated' do
        post_as @admin, :create, @attributes
        new_assignment = Assignment.find_by_short_identifier(@short_identifier)
        assert_not_nil new_assignment.assignment_stat
        assert respond_with :redirect
        assert set_the_flash
      end

      should "set the flash's success message" do
        post_as @admin, :create, @attributes
        new_assignment = Assignment.find_by_short_identifier(@short_identifier)
        assert_equal 'Successfully created the assignment', flash[:success]
      end

      context 'with section due dates' do
        setup do
          @section1 = Section.make
          @section2 = Section.make
        end

        should 'be able to create assignment with section due dates' do
          @attributes['assignment']['section_due_dates_type'] = '1'
          due_date_attributes = {
            '0' => { 'section_id' => "#{@section1.id}",
                     'due_date'   => '2011-10-27 00:00' },
            '1' => { 'section_id' => "#{@section2.id}",
                     'due_date'   => '2011-10-29 00:00' }
          }
          @attributes['assignment']['section_due_dates_attributes'] =
            due_date_attributes

          post_as @admin, :create, @attributes
          new_assignment =
            Assignment.where(short_identifier: @short_identifier).first

          assert_not_nil new_assignment
          assert_equal true, new_assignment.section_due_dates_type
          due_date_attributes.each do |key, value|
            date     = Time.parse(value['due_date'])
            due_date =
              new_assignment.section_due_dates
                            .find { |d| d.due_date == date }
            refute_nil due_date, "Due date not added for section #{key}"
            assert_equal value['section_id'].to_i, due_date.section_id
          end
          assert redirect_to(action: 'edit', id: new_assignment)
        end

        should 'be able to create assignment due date with some section due dates set' do
          # A section due date can be nil
          # That section then uses the main due_date
          @attributes['assignment']['section_due_dates_type'] = '1'
          due_date_attributes = {
            '0' => { 'section_id' => "#{@section1.id}",
                     'due_date'   => nil },
            '1' => { 'section_id' => "#{@section2.id}",
                     'due_date'   => '2011-10-29 00:00' }
          }
          @attributes['assignment']['section_due_dates_attributes'] =
            due_date_attributes

          post_as @admin, :create, @attributes

          new_assignment =
            Assignment.where(short_identifier: @short_identifier).first

          assert_not_nil new_assignment
          assert_equal true, new_assignment.section_due_dates_type
          assert_nil new_assignment.section_due_dates[0].due_date

          expected_date = new_assignment.section_due_dates[1].due_date
          actual_date   = Time.parse(due_date_attributes['1']['due_date'])
          assert_equal expected_date, actual_date

          assert redirect_to(action: 'edit', id: new_assignment)
        end
      end  # With some sections
    end #creating new assignment

    should 'be able to get a new assignment form with submission rules HTML present' do
      get_as @admin, :new
      assert_not_nil response.body.to_s.match('NoLateSubmissionRule')
      assert_not_nil response.body.to_s.match('GracePeriodSubmissionRule')
      assert_not_nil response.body.to_s.match('PenaltyDecayPeriodSubmissionRule')
      assert_not_nil response.body.to_s.match('PenaltyPeriodSubmissionRule')
    end

    should 'with REPOSITORY_EXTERNAL_SUBMITS_ONLY as false' do
      MarkusConfigurator.stubs(
        :markus_config_repository_external_submits_only?).returns(false)
      get_as @admin, :new
      assignment = assigns(:assignment)
      assert assignment.allow_web_submits
    end  # -- with REPOSITORY_EXTERNAL_SUBMITS_ONLY as false

    should 'with REPOSITORY_EXTERNAL_SUBMITS_ONLY as true' do
      MarkusConfigurator.stubs(
        :markus_config_repository_external_submits_only?).returns(true)
      get_as @admin, :new
      assignment = assigns(:assignment)
      assert !assignment.allow_web_submits
    end  # -- with REPOSITORY_EXTERNAL_SUBMITS_ONLY as true

    context 'with an assignment' do
      setup do
        @assignment = Assignment.make
      end

      should 'get edit form if not post' do
        get_as @admin,
              :edit,
              :id => @assignment.id
        assert_response :success
        assert assigns :assignment
      end

      should 'be able to edit a new assignment form with submission rules HTML present' do
        get_as @admin,
              :edit,
              :id => @assignment.id
        assert_not_nil response.body.to_s.match('NoLateSubmissionRule')
        assert_not_nil response.body.to_s.match('GracePeriodSubmissionRule')
        assert_not_nil response.body.to_s.match('PenaltyDecayPeriodSubmissionRule')
        assert_not_nil response.body.to_s.match('PenaltyPeriodSubmissionRule')
      end

      should 'bounced off from student interface' do
        get_as @admin,
               :student_interface,
               :id => @assignment.id
        assert_response :missing
      end

      should 'update group properties on persist' do
        get_as  @admin,
                :update_group_properties_on_persist,
                :assignment_id => @assignment.id
        assert assigns(:assignment)
        assert_equal @assignment, assigns(:assignment)
      end

      should 'edit basic paramaters' do
        put_as @admin,
                :update,
                :id => @assignment.id,
                :assignment => {
                  :short_identifier => 'New SI',
                  :description => 'New Description',
                  :message => 'New Message',
                  :due_date => 3.days.from_now,
                  :submission_rule_attributes => {
                    :type => @assignment.submission_rule.type.to_s,
                    :id => @assignment.submission_rule.id
                  }
                }
        @assignment.reload
        assert_equal 'New SI', @assignment.short_identifier
        assert_equal 'New Description', @assignment.description
        assert_equal 'New Message', @assignment.message
        assert ((3.days.from_now - @assignment.due_date).abs < 5)
      end

      should 'not be able to edit with invalid assignment' do
        put_as @admin,
               :update,
               :id => @assignment.id,
               :assignment => {
                  :short_identifier => '',
                  :description => 'New Description',
                  :message => 'New Message',
                  :due_date => 3.days.from_now,
                  :submission_rule_attributes => {
                    :type => @assignment.submission_rule.type.to_s,
                    :id => @assignment.submission_rule.id}}
        a = Assignment.find(@assignment.id)
        assert_equal @assignment.short_identifier, a.short_identifier
        assert_equal @assignment.description, a.description
        assert_equal @assignment.message, a.message
        assert_equal @assignment.due_date, a.due_date
        assert_not_nil assigns(:assignment)
        assert !assigns(:assignment).errors.empty?
      end

      should 'not be able to edit with invalid submission rules' do
        put_as @admin,
                :update,
                :id => @assignment.id,
                :assignment => {
                  :short_identifier => 'New SI',
                  :description => 'New Description',
                  :message => 'New Message',
                  :due_date => 3.days.from_now,
                  :submission_rule_attributes => {
                    :type => 'UnknownClass',
                    :id => @assignment.submission_rule.id}}
        a = Assignment.find(@assignment.id)
        assert_equal @assignment.short_identifier, a.short_identifier
        assert_equal @assignment.description, a.description
        assert_equal @assignment.message, a.message
        assert_equal @assignment.due_date, a.due_date
        assert_equal @assignment.submission_rule.type.to_s,
                     a.submission_rule.type.to_s
        assert_not_nil assigns(:assignment)
        refute_empty assigns(:assignment).errors
      end

      should 'be able to add periods to submission rule class' do
        put_as @admin,
                :update,
                {:id => @assignment.id,
                 :assignment => {
                   :short_identifier => 'New SI',
                   :description => 'New Description',
                   :message => 'New Message',
                   :due_date => 3.days.from_now,
                   :submission_rule_attributes => {
                     :type => 'PenaltyPeriodSubmissionRule',
                     :id => @assignment.submission_rule.id,
                     :periods_attributes => [
                       {:deduction => '10', :hours => '24'},
                       {:deduction => '20', :hours => '24'}
                     ]}}}
        @assignment.reload
        assert_equal 'New SI', @assignment.short_identifier
        assert_equal 'New Description', @assignment.description
        assert_equal 'New Message', @assignment.message
        assert_equal 'PenaltyPeriodSubmissionRule',
                     @assignment.submission_rule.type.to_s
        assert_equal 2, @assignment.submission_rule.periods.length
        first_period = @assignment.submission_rule.periods.first
        last_period = @assignment.submission_rule.periods.last
        assert_equal 10, first_period.deduction
        assert_equal 24, first_period.hours
        assert_equal 20, last_period.deduction
        assert_equal 24, last_period.hours

        assert_not_nil assigns(:assignment)
        assert assigns(:assignment).errors.empty?
      end

      # Regression test for Github issue #568
      should 'receieve errors when providing invalid period attributes for a submission rule' do
        put_as @admin,
                :update,
                {:id => @assignment.id,
                 :assignment => {
                   :submission_rule_attributes => {
                     :type => 'PenaltyPeriodSubmissionRule',
                     :periods_attributes => {
                        '1' => { :hours => nil, :deduction => nil} },
                     :id => @assignment.submission_rule.id,
                     }}}

        @assignment.reload
        # note that a div with this id is only displayed when we have an error on a page
        assert_select 'div.error'
      end

      # Regression test for Github issue #568
      should 'be able to switch submission rule when editing an assignment' do
        # First make sure that the current submission rule is one with periods
        # which we can then switch to NoLateSubmissionRule via a put_as
        rule = GracePeriodSubmissionRule.make
        period = Period.make
        period.submission_rule = rule
        assert period.save
        assert rule.periods.length > 0
        @assignment = Assignment.make( :submission_rule => rule )
        assert @assignment.submission_rule.is_a?(GracePeriodSubmissionRule)

        put_as @admin,
               :update,
               id: @assignment.id,
               assignment: {
                 submission_rule_attributes: {
                   type: 'NoLateSubmissionRule',
                   periods_attributes: {
                     '1' => { id: period.id, hours: 1 }
                   },
                   id: @assignment.submission_rule.id,
                 }
               }

        assert_response :redirect
        # no errors should have been produced
        assert_equal [], assigns(:assignment).errors[:base]

        @assignment.reload
        assert @assignment.submission_rule.is_a?(NoLateSubmissionRule)
        assert_equal I18n.t('assignment.update_success'), flash[:success]
      end

      should 'be able to set instructor forms groups' do
        @assignment = Assignment.make( :student_form_groups => true )
        assert @assignment.student_form_groups
        put_as @admin,
                :update,
                {:id => @assignment.id,
                 :assignment => {
                   :description => 'New Description',
                   :message => 'New Message',
                   :due_date => 3.days.from_now,
                   :student_form_groups => '0',
                   :submission_rule_attributes => {
                     :type => 'NoLateSubmissionRule',
                     :id => @assignment.submission_rule.id}},
                   :is_group_assignment => 'true'}

        a = Assignment.find(@assignment.id)
        assert_equal 'New Description', a.description
        assert_equal 'New Message', a.message
        assert_equal @assignment.submission_rule.type.to_s,
                     a.submission_rule.type.to_s
        assert !a.student_form_groups
        assert_not_nil assigns(:assignment)
        assert assigns(:assignment).errors.empty?
      end

      should 'be able to set students to form groups' do
        @assignment = Assignment.make( :student_form_groups => false )
        assert !@assignment.student_form_groups
        put_as @admin,
                :update,
                { :id => @assignment.id,
                  :is_group_assignment => 'true',
                  :assignment => {
                    :student_form_groups => '1',
                    :submission_rule_attributes => {
                      :type => 'NoLateSubmissionRule',
                      :id => @assignment.submission_rule.id
                    }
                  }
                }

        @assignment.reload
        assert_redirected_to edit_assignment_path(@assignment)
        assert_equal I18n.t('assignment.update_success'),
               flash[:success]

        assert_not_nil assigns(:assignment)
        assert assigns(:assignment).errors.empty?
        assert @assignment.student_form_groups
      end

      should 'get assignments list' do
        submission_rule = NoLateSubmissionRule.make
        submission_rule.stubs(:can_collect_now?).returns(false)
        Assignment.any_instance.stubs(
            :submission_rule).returns(submission_rule)
        get_as @admin, :index
        assert assigns(:assignments)
        assert_response :success
      end

      should 'be able to get a csv grade report' do
        student = Student.make
        response_csv = get_as(@admin, :download_csv_grades_report).body
        csv_rows = CSV.parse(response_csv)
        assert_equal Student.all.size, csv_rows.size
        assignments = Assignment.all(:order => 'id')
        csv_rows.each do |csv_row|
          student_name = csv_row.shift
          student = Student.find_by_user_name(student_name)
          assert_not_nil student
          assert_equal assignments.size, csv_row.size

          csv_row.each_with_index do |final_mark,index|
            if final_mark.blank?
              if student.has_accepted_grouping_for?(assignments[index])
                grouping = student.accepted_grouping_for(assignments[index])
                assert (!grouping.has_submission? ||
                        assignments[index].total_mark == 0)
              end
            else
              out_of = assignments[index].total_mark
              grouping = student.accepted_grouping_for(assignments[index])
              assert_not_nil grouping
              assert grouping.has_submission?
              submission = grouping.current_submission_used
              assert_not_nil submission.get_latest_result
              assert_equal final_mark.to_f.round,
                           (submission.get_latest_result.total_mark / out_of * 100
                           ).to_f.round
            end
          end
        end
        assert_response :success
      end

      context 'with required files' do
        setup do
          @file_1 = AssignmentFile.make(:assignment => @assignment)
          @file_2 = AssignmentFile.make(:assignment => @assignment)
        end

        should 'be able to remove required files' do
          put_as @admin,
                  :update,
                  :id => @assignment.id,
                  :assignment => {
                      :short_identifier => @assignment.short_identifier,
                      :description => @assignment.description,
                      :message => @assignment.message,
                      :due_date => @assignment.due_date,
                      :assignment_files_attributes => {
                        '1' => { :id => @file_1.id,
                                :filename => @file_1.filename,
                                :_destroy => '0' },
                        '2' => { :id => @file_2.id,
                                :filename => @file_2.filename,
                                :_destroy => '1' }},
                      :submission_rule_attributes => {
                        :type => @assignment.submission_rule.type.to_s,
                        :id => @assignment.submission_rule.id}}
          @assignment.reload
          assert_equal 1, @assignment.assignment_files.count
          assert_equal @file_1, @assignment.assignment_files.first
        end
      end  # -- with required files

      should 'be able to add section due dates' do
        put_as @admin,
                  :update,
                  :id => @assignment.id,
                  :assignment => {
                    :short_identifier => @assignment.short_identifier,
                    :description => @assignment.description,
                    :message => @assignment.message,
                    :due_date => @assignment.due_date,
                    :submission_rule_attributes => {
                      :type => @assignment.submission_rule.type.to_s,
                      :id => @assignment.submission_rule.id
                    },
                    :section_due_dates_type => '1',
                    :section_due_dates_attributes => {
                      '0' => { 'section_id' => '2', 'due_date' => '2011-10-27 00:00' },
                      '1' => { 'section_id' => '3', 'due_date' => '2011-10-27 00:00' }
                    }
                  }
        @assignment.reload
        assert_equal true, @assignment.section_due_dates_type
        assert_equal 2, @assignment.section_due_dates.size
      end

      should 'be able to remove section due dates after adding them' do
        put_as @admin,
                  :update,
                  :id => @assignment.id,
                  :assignment => {
                    :short_identifier => @assignment.short_identifier,
                    :description => @assignment.description,
                    :message => @assignment.message,
                    :due_date => @assignment.due_date,
                    :submission_rule_attributes => {
                      :type => @assignment.submission_rule.type.to_s,
                      :id => @assignment.submission_rule.id
                    },
                    :section_due_dates_type => '1',
                    :section_due_dates_attributes => {
                      '0' => { 'section_id' => '2', 'due_date' => '2011-10-27 00:00' },
                      '1' => { 'section_id' => '3', 'due_date' => '2011-10-27 00:00' }
                    }
                  }
        put_as @admin,
          :update,
          :id => @assignment.id,
          :assignment => {
            :short_identifier => @assignment.short_identifier,
            :description => @assignment.description,
            :message => @assignment.message,
            :due_date => @assignment.due_date,
            :submission_rule_attributes => {
              :type => @assignment.submission_rule.type.to_s,
              :id => @assignment.submission_rule.id
            },
            :section_due_dates_type => '0',
            :section_due_dates_attributes => {
              '0' => { 'section_id' => '2', 'due_date' => '2011-10-27 00:00' },
              '1' => { 'section_id' => '3', 'due_date' => '2011-10-27 00:00' }
            }
          }

        @assignment.reload
        assert_equal false, @assignment.section_due_dates_type
        assert_empty @assignment.section_due_dates
        assert_empty SectionDueDate.all
      end
    end  # -- with an assignment

    context 'with a hidden assignment' do
      setup do
        @assignment = Assignment.make(:short_identifier => 'AHidden',:is_hidden => true)
      end

      should 'be able to view it' do
        get_as @admin, :index
        assert @response.body.include?(@assignment.short_identifier)
      end
    end # -- with a hidden assignment

    context ', on :download_assignment_list,' do

      should 'be able to download a csv file' do
        get_as @admin, :download_assignment_list, :file_format => 'csv'
        assert_response :success
        assert_equal 'text/csv', response.header['Content-Type']
      end

      should 'be able to download a yml file' do
        get_as @admin, :download_assignment_list, :file_format => 'yml'
        assert_response :success
        assert_equal 'text/yml', response.header['Content-Type']
      end

      should 'not be able to download an xml file' do
        get_as @admin, :download_assignment_list, :file_format => 'xml'
        assert_response :redirect
        assert set_the_flash.to((I18n.t(:incorrect_format)))
      end
    end

    context ', on :upload_assignment_list,' do

      should 'be able to upload a csv file' do
        post_as @admin,
                :upload_assignment_list,
                :assignment_list => fixture_file_upload('../files/new_assignments.csv'),
                :file_format => 'csv'
        assert_response :redirect
        assert_redirected_to(:controller => 'assignments', :action => 'index')
        assert_equal flash[:success], I18n.t('assignment.create_success')
        assert_equal flash[:error], nil
        test1 = Assignment.find_by_short_identifier('ATest1')
        assert_not_nil test1
        test2 = Assignment.find_by_short_identifier('ATest2')
        assert_not_nil test2
        assert_generates '/assignments/upload_assignment_list', :controller => 'assignments', :action => 'upload_assignment_list'
        assert_recognizes({:controller => 'assignments', :action => 'upload_assignment_list' },
                          {:path => 'assignments/upload_assignment_list', :method => :post})
      end

      should 'be able to upload a yml file' do
        post_as @admin,
                :upload_assignment_list,
                :assignment_list => fixture_file_upload('../files/new_assignments.yml'),
                :file_format => 'yml', :encoding => 'UTF-8'
        assert_response :redirect
        assert_redirected_to(:controller => 'assignments', :action => 'index')
        assert_equal flash[:success], I18n.t('assignment.create_success')
        assert_equal flash[:error], nil
        test1 = Assignment.find_by_short_identifier('ATest3')
        assert_not_nil test1
        test2 = Assignment.find_by_short_identifier('ATest4')
        assert_not_nil test2
        assert_generates '/assignments/upload_assignment_list', :controller => 'assignments', :action => 'upload_assignment_list'
        assert_recognizes({:controller => 'assignments', :action => 'upload_assignment_list' },
                          {:path => 'assignments/upload_assignment_list', :method => :post})
      end

      should 'not be able to upload a file without require fields' do
        post_as @admin,
                :upload_assignment_list,
                :assignment_list => fixture_file_upload('../files/new_assignments.yml'),
                :file_format => 'csv'
        assert_response :redirect
        assert_redirected_to(:controller => 'assignments', :action => 'index')
        assert_equal flash[:success], nil
        assert_not_equal flash[:error], nil
        test1 = Assignment.find_by_short_identifier('ATest5')
        assert_nil test1
      end

      should 'gracefully handle a non csv file with a csv extension' do
        tempfile = fixture_file_upload('files/pdf_with_csv_extension.csv')
        post_as @admin,
                :upload_assignment_list,
                assignment_list: tempfile,
                file_format: 'csv',
                encoding: 'UTF-8'

        assert_response :redirect
        assert_equal flash[:error],
                     I18n.t('csv.upload.non_text_file_with_csv_extension')
      end
    end

  end  # -- an Admin

  context 'A grader' do
    setup do
      @grader = Ta.make
    end

    should 'not be able to CSV graders report' do
      get_as @grader, :download_csv_grades_report
      assert_response :missing
    end

    context 'with an assignment' do
      setup do
        @assignment = Assignment.make
      end

      should 'not be able to edit' do
          get_as @grader,
                 :edit,
                 :id => @assignment.id
          assert_response :missing
      end

      should 'bounced from student interface' do
        get_as @grader,
               :student_interface,
               :id => @assignment.id
        assert_response :missing
      end

      should 'not be able to get group properties' do
        get_as @grader,
               :update_group_properties_on_persist,
               :assignment_id => @assignment.id
        assert_response :missing
      end

      should 'gets assignment list on the graders' do
        submission_rule = NoLateSubmissionRule.make
        submission_rule.stubs(:can_collect_now?).returns(false)
        Assignment.any_instance.stubs(:submission_rule).returns(
                submission_rule)
        get_as @grader, :index
        assert assigns(:assignments)
        assert_response :success
      end

    end  # -- with an Assignment

    context 'with a hidden assignment' do
      setup do
        @assignment = Assignment.make(:short_identifier => 'AHidden',:is_hidden => true)
      end

      should 'be able to view it' do
        get_as @grader, :index
        assert @response.body.include?(@assignment.short_identifier)
      end
    end # -- with a hidden assignment
  end  # -- with a Grader

  context 'A student' do
    setup do
      @student = Student.make
    end

    context 'with an assignment' do
      setup do
        @assignment = Assignment.make(:group_min => 2)
      end

      should "get assignment's index" do
        get_as @student, :index
        assert assigns(:a_id_results)
        assert assigns(:assignments)
        assert_response :success
      end

      should 'not be able to get group properties' do
        get_as @student,
               :update_group_properties_on_persist,
               :assignment_id => @assignment.id
        assert_response :missing
      end

      should 'not be able to access grades report' do
        get_as @student, :download_csv_grades_report
        assert_response :missing
      end

      should 'not be able to edit assignment' do
        get_as @student, :edit, :id => @assignment.id
        assert_response :missing
      end

      should 'be able to get the student interface' do
        get_as @student,
               :student_interface,
               :id => @assignment.id
        assert assigns(:assignment)
        assert assigns(:pending_grouping).nil?
        assert_response :success
      end

      should 'be able to create a group' do
        post_as(@student, :creategroup, {:id => @assignment.id})
        assert_redirected_to :action => 'student_interface',
                             :id => @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
      end

      should 'not be able to invite without a group' do
        students = [Student.make, Student.make]
        user_names = students.collect{
                          |student| student.user_name
                        }.join(', ')
        assert_raise RuntimeError do
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => user_names})
        end
      end

      should 'not be able to work alone' do
        post_as @student,
                :creategroup,
                {:id => @assignment.id, :workalone => 'true'}

        assert_redirected_to :action => 'student_interface',
                             :id => @assignment.id
        assert_equal I18n.t('create_group.fail.can_not_work_alone',
                            :group_min => @assignment.group_min),
                     flash[:fail_notice]
        assert !@student.has_accepted_grouping_for?(@assignment.id)
      end

      context 'invited in several group' do
        setup do
          @grouping = Grouping.make(:assignment => @assignment)
          StudentMembership.make(
              :grouping => @grouping,
              :user => @student,
              :membership_status => StudentMembership::STATUSES[:pending])
          StudentMembership.make(
              :grouping => @grouping,
              :membership_status => StudentMembership::STATUSES[:inviter])

          g = Grouping.make(:assignment => @assignment)
          StudentMembership.make(
              :grouping => g,
              :user => @student,
              :membership_status => StudentMembership::STATUSES[:pending])
          StudentMembership.make(
              :grouping => g,
              :membership_status => StudentMembership::STATUSES[:inviter])

        end

        should 'be able to join a group' do
          post_as @student, :join_group, {:id => @assignment.id,
                                          :grouping_id => @grouping.id}
          assert @student.has_accepted_grouping_for?(@assignment.id),
                'should have accepted grouping for this assignment'
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
        end

        should 'see all the pending invitations' do
          get_as @student, :student_interface, :id => @assignment.id
          assert_response :success
          assert assigns(:pending_grouping)
          assert_equal 2, assigns(:pending_grouping).length
        end

        should 'be able to decline an invitation' do
          post_as(@student,
                  :decline_invitation,
                  {:id => @assignment.id,
                   :grouping_id => @grouping.id} )
          assert !@student.has_accepted_grouping_for?(@assignment.id),
                 'should not have accepted groupings for this assignment'
        end
      end

      context ', inviter of a group' do
        setup do
          @grouping = Grouping.make(:assignment => @assignment)
          StudentMembership.make(
              :user => @student,
              :grouping => @grouping,
              :membership_status => StudentMembership::STATUSES[:inviter])
        end

        should 'be able to invite a student' do
          student = Student.make
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => student.user_name})
          assert_equal(I18n.t('invite_student.success'), flash[:success])
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
        end

        should "not be able to invite a student that doesn't exist" do
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => 'zhfbdjhzkyfg'})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal(I18n.t('invite_student.fail.dne',
                              :user_name => 'zhfbdjhzkyfg'),
                       flash[:fail_notice].first)
        end

        should 'not be able to invite a hidden student' do
          student = Student.make(:hidden => true)
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => student.user_name})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal(I18n.t('invite_student.fail.hidden',
                              :user_name => student.user_name),
                       flash[:fail_notice].first)
        end

        should 'not be able to invite an already invited student' do
          sm = StudentMembership.make(:grouping => @grouping)
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                  :invite_member => sm.user.user_name})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal(I18n.t('invite_student.fail.already_pending',
                              :user_name => sm.user.user_name),
                       flash[:fail_notice].first)
        end

        should 'be able to invite multiple students' do
          students = [Student.make, Student.make]
          user_names = students.collect{
                |student| student.user_name
              }.join(',')
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id, :invite_member => user_names})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal 2, @grouping.pending_students.size
        end

        should 'be able to invite multiple students with malformed string' do
          students = [Student.make, Student.make]
          invalid_users = ['%(*&@#$(*#$EJDF',
                           'falsj asdlfkjasdl aslkdjasd,dasflk(*!@*@*@!!!',
                           'lkjsdlkfjsdfsdlkfjsfsdf']
          user_names = ((students.collect{
                          |student| student.user_name
                         }) + invalid_users).join(',')
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => user_names})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal 2, @grouping.pending_students.size
        end

        should 'be able to invite students with spacing' do
          students = [Student.make, Student.make]
          user_names = students.collect{
                          |student| student.user_name
                        }.join(' ,  ')
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => user_names})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal 2, @grouping.pending_students.size
        end

        should 'not be able to invite self to a group' do
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => @student.user_name})
          assert_equal(I18n.t('invite_student.fail.inviting_self'),
                       flash[:fail_notice].first)
        end

        should 'not be able to invite admins' do
          admin = Admin.make
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => admin.user_name})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal 0, @grouping.pending_students.size
          assert_equal(I18n.t('invite_student.fail.dne',
                              :user_name => admin.user_name),
                      flash[:fail_notice].first)
        end

        should 'not be able to invite graders' do
          grader = Ta.make
          post_as(@student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => grader.user_name})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal 0, @grouping.pending_students.size
          assert_equal(I18n.t('invite_student.fail.dne',
                              :user_name => grader.user_name),
                       flash[:fail_notice].first)
        end

        should 'not be able to create another group' do
          post_as(@student,
                  :creategroup,
                  {:id => @assignment.id})
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal I18n.t('create_group.fail.already_have_a_group'),
                       flash[:fail_notice]
          assert @student.has_accepted_grouping_for?(@assignment.id)
          assert_equal @grouping,
                       @student.accepted_grouping_for(@assignment.id)
        end

        should 'be able to delete rejected membership' do
          sm = StudentMembership.make(
                  :grouping => @grouping,
                  :membership_status => StudentMembership::STATUSES[:pending])

          assert_nothing_raised do
            post_as(@student,
                    :delete_rejected,
                    {:id => @assignment.id,
                     :membership => sm.id})
          end

          assert_raise ActiveRecord::RecordNotFound do
            StudentMembership.find(sm.id)
          end
          assert_redirected_to :controller => 'assignments',
                               :action => 'student_interface',
                               :id => @assignment.id
          assert_response :redirect
        end

        should 'be able to disinvite someone' do
          sm = StudentMembership.make(
                  :grouping => @grouping,
                  :membership_status => StudentMembership::STATUSES[:rejected])
          post_as @student,
                  :disinvite_member,
                  {:id => @assignment.id,
                   :membership => sm.id}

          assert_response :success
          assert_equal I18n.t('student.member_disinvited'),
                       flash[:edit_notice]
          assert_equal 1,
                       @grouping.memberships.length
        end

        should 'be able to delete an not valid group ' do
          assert !@grouping.is_valid?
          post_as @student,
                  :deletegroup,
                  {:id => @assignment.id, :grouping_id => @grouping.id}

          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id

          assert_equal(I18n.t('assignment.group.deleted'), flash[:edit_notice])
          assert !@student.has_accepted_grouping_for?(@assignment.id)
        end

        context 'with pending invitations' do
          setup do
            @invited = Student.make
            sm = StudentMembership.make(
                  :grouping => @grouping,
                  :membership_status => StudentMembership::STATUSES[:pending],
                  :user => @invited)

          end

          should 'not be able to invite someone already invited' do
            post_as @student,
                    :invite_member,
                    {:id => @assignment.id,
                     :invite_member => @invited.user_name}
            assert_redirected_to :action => 'student_interface',
                                 :id => @assignment.id
            assert flash[:fail_notice].include?(
                      I18n.t('invite_student.fail.already_pending',
                             :user_name => @invited.user_name))
          end
        end  # -- with pending invitations

        context 'which is valid' do
          setup do
             sm = StudentMembership.make(
                :grouping => @grouping,
                :membership_status => StudentMembership::STATUSES[:accepted])
             sm = StudentMembership.make(
                :grouping => @grouping,
                :membership_status => StudentMembership::STATUSES[:accepted])

          end

          should 'not be able to delete the group' do
            assert @grouping.is_valid?
            post_as @student,
                    :deletegroup,
                    {:id => @assignment.id,
                     :grouping_id => @grouping.id}
            assert_redirected_to :action => 'student_interface',
                                 :id => @assignment.id
            assert_equal I18n.t('groups.cant_delete'), flash[:fail_notice]
            assert @student.has_accepted_grouping_for?(@assignment.id)

          end
        end

        context 'with a submission' do
          setup do
            submission = Submission.make(:grouping => @grouping)
          end

          should 'not be able to delete a group' do
            post_as @student,
                    :deletegroup,
                    {:id => @assignment.id}
            assert_equal I18n.t('groups.cant_delete_already_submitted'),
                        flash[:fail_notice]
            assert @student.has_accepted_grouping_for?(@assignment.id)
          end
        end  # -- with pending invitations
      end  # -- Inviter of a group

      context 'in a group' do
        setup do
          @grouping = Grouping.make(:assignment => @assignment)
          @sm = StudentMembership.make(
                 :grouping => @grouping,
                 :membership_status => StudentMembership::STATUSES[:accepted],
                 :user => @student)
        end

        should 'not be able to delete rejected membership' do
          assert_raise RuntimeError do
            post_as @student,
                    :delete_rejected,
                    :id => @assignment.id,
                    :membership => @sm.id
          end
          assert_nothing_raised do
            membership = StudentMembership.find(@sm.id)
          end
          assert !@sm.nil?
          assert_response :success
        end

        should 'not be able to delete group' do
          post_as @student,
                  :deletegroup, {:id => @assignment.id}
          assert_equal I18n.t('groups.cant_delete'), flash[:fail_notice]
          assert @student.has_accepted_grouping_for?(@assignment.id)
        end
      end  # -- in a group
    end  # -- with an assignment

    context 'with an assignment with group = 1' do
      setup do
        @assignment = Assignment.make(:group_min => 1)
      end

      should 'be able to work alone' do
        post_as @student,
                :creategroup,
                {:id => @assignment.id,
                 :workalone => 'true'}
        assert_redirected_to :action => 'student_interface',
                             :id => @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
        grouping = @student.accepted_grouping_for(@assignment.id)
        assert grouping.is_valid?
      end
    end  # -- with an assignment with group_min = 1

    context 'with an assignment where instructors creates groups' do
      setup do
        @assignment = Assignment.make(:student_form_groups => false)
      end

      should 'not be able to allow to form groups' do
        post_as @student,
                :creategroup,
                {:id => @assignment.id}

        assert_equal I18n.t('create_group.fail.not_allow_to_form_groups'),
                    flash[:fail_notice]
      end

      context 'with a group' do
        setup do
          @grouping = Grouping.make(:assignment => @assignment)
          StudentMembership.make(
              :grouping => @grouping,
              :membership_status => StudentMembership::STATUSES[:accepted],
              :user => @student)

        end

        should 'not be able to delete grouping' do
          post_as @student,
                  :deletegroup,
                  {:id => @assignment.id,
                   :grouping_id => @grouping.id}
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id
          assert_equal(I18n.t('groups.cant_delete'), flash[:fail_notice])
          assert @student.has_accepted_grouping_for?(@assignment.id)

        end
      end
    end  # -- with an assignment where instructors creates groups

    context 'with an assignment where students have to work alone' do
      setup do
        @assignment = Assignment.make(:group_min => 1,
                                      :group_max => 1)
      end

      should 'create group automatically' do
        get_as @student, :student_interface, :id => @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
        assert_not_nil @student.accepted_grouping_for(@assignment.id)
        assert_equal @student,
                     @student.accepted_grouping_for(@assignment.id).inviter
        assert_redirected_to :action => 'student_interface',
                             :id => @assignment.id
      end
    end  # -- with an assignment where students have to work alone

    context 'with an assignment, with a past due date' do
      setup do
        @assignment = Assignment.make(:due_date => 3.days.ago)
      end

      context 'inviter of a group' do
        setup do
          @grouping = Grouping.make(:assignment => @assignment)
          sm = StudentMembership.make(
                 :grouping => @grouping,
                 :membership_status => StudentMembership::STATUSES[:inviter],
                 :user => @student)
        end

        should 'not be able to invite' do
          student = Student.make
          post_as @student,
                  :invite_member,
                  {:id => @assignment.id,
                  :invite_member => student.user_name}
          assert_redirected_to :action => 'student_interface',
                              :id => @assignment.id
          assert_equal I18n.t('invite_student.fail.due_date_passed',
                              :user_name => student.user_name),
                      flash[:fail_notice].first
        end
      end
    end  # -- with an assignment, with a past due date

    context 'with an assignmt, with past due date but collection in future' do
      setup do
        @assignment = Assignment.make(:due_date => 1.days.ago)
        grace_period_submission_rule = GracePeriodSubmissionRule.new
        @assignment.replace_submission_rule(grace_period_submission_rule)
        @assignment.save
        Period.make(:submission_rule_id => @assignment.submission_rule.id,
                    :hours => 62)
      end

      should 'have the create group link available' do
        get_as @student,
               :student_interface,
               :id => @assignment.id
        assert_not_nil (response.body =~ /<a[^>]*>#{I18n.t(:create)}<\/a>/)
      end

      should 'be able to create a group' do
        post_as @student, :creategroup, :id => @assignment.id
        assert_redirected_to :action => 'student_interface',
                             :id => @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
      end

      context 'with a grouping' do
        setup do
          @grouping = Grouping.make(:assignment => @assignment)
          StudentMembership.make(
              :grouping => @grouping,
              :membership_status => StudentMembership::STATUSES[:inviter],
              :user => @student)

        end

        should 'be able to invite a student' do
          student = Student.make
          post_as @student,
                  :invite_member,
                  {:id => @assignment.id,
                   :invite_member => student.user_name}
          assert_equal(I18n.t('invite_student.success'), flash[:success])
          assert_redirected_to :action => 'student_interface',
                               :id => @assignment.id

        end
      end
    end # -- with an assignmt, with past due date but collection in future'

    context 'with a hidden assignment' do
      setup do
        @assignment = Assignment.make(:short_identifier => 'AHidden',:is_hidden => true)
      end

      should 'not be able to view it' do
        get_as @student, :index
        assert !@response.body.include?(@assignment.short_identifier)
      end
    end
  end  # -- A student
end
