require File.expand_path(File.join(File.dirname(__FILE__), 'authenticated_controller_test'))
require File.expand_path(File.join(File.dirname(__FILE__), '..', 'blueprints', 'blueprints'))
require File.expand_path(File.join(File.dirname(__FILE__), '..', 'blueprints', 'helper'))

require 'shoulda'
require 'machinist'
require 'time-warp'

class AssignmentsControllerTest < AuthenticatedControllerTest

  def setup
    @controller = AssignmentsController.new
    @request = ActionController::TestRequest.new
    @response = ActionController::TestResponse.new
  end

  def teardown
    destroy_repos
  end

  context 'An admin' do
    setup do
      @admin = Admin.make
    end

    should 'be able to get new' do
      get_as @admin, :new
      assert_not_nil assigns :assignment
      assert_not_nil assigns :assignments
      assert_response :success
    end

    context 'creating a new assignment' do
      setup do
        @short_identifier = Sham.short_identifier
        @attributes = { 'commit' => 'Submit',
                        'assignment' => {'student_form_groups' => '0',
                                        'group_name_autogenerated' => '0',
                                        'short_identifier' => @short_identifier,
                                        'repository_folder' => "/#{@short_identifier}",
                                        'group_max' =>'1',
                                        'due_date' => 2.days.from_now,
                                        'display_grader_names_to_students' =>'false',
                                        'allow_web_submits' =>'true',
                                        'description' => Sham.description,
                                        'allow_remarks' =>'true',
                                        'submission_rule_attributes' =>
                                          { 'type' =>'NoLateSubmissionRule' },
                                        'group_min' =>'1'
                       }
        }
      end

      should 'have created the assignment and redirected properly' do
        post_as @admin, :create, @attributes
        new_assignment = Assignment.find_by_short_identifier(@short_identifier)
        assert_not_nil new_assignment
        assert redirect_to(action: 'edit', id: new_assignment)
      end

      should 'have an assignment stat object associated' do
        post_as @admin, :create, @attributes
        new_assignment = Assignment.find_by_short_identifier(@short_identifier)
        assert_not_nil new_assignment.assignment_stat
        assert respond_with :redirect
        assert set_flash
      end

      should "set the flash's success message" do
        post_as @admin, :create, @attributes
        new_assignment = Assignment.find_by_short_identifier(@short_identifier)
        assert_equal ['Successfully created the assignment'], flash[:success]
      end

      context 'with section due dates' do
        setup do
          @section1 = Section.make
          @section2 = Section.make
        end

        should 'be able to create assignment with section due dates' do
          @attributes['assignment']['section_due_dates_type'] = '1'
          due_date_attributes = {
            '0' => { 'section_id' => "#{@section1.id}",
                     'due_date'   => '2011-10-27 00:00' },
            '1' => { 'section_id' => "#{@section2.id}",
                     'due_date'   => '2011-10-29 00:00' }
          }
          @attributes['assignment']['section_due_dates_attributes'] =
            due_date_attributes

          post_as @admin, :create, @attributes
          new_assignment =
            Assignment.where(short_identifier: @short_identifier).first

          assert_not_nil new_assignment
          assert_equal true, new_assignment.section_due_dates_type
          due_date_attributes.each do |key, value|
            date     = Time.parse(value['due_date'])
            due_date =
              new_assignment.section_due_dates
                            .find { |d| d.due_date == date }
            refute_nil due_date, "Due date not added for section #{key}"
            assert_equal value['section_id'].to_i, due_date.section_id
          end
          assert redirect_to(action: 'edit', id: new_assignment)
        end

        should 'be able to create assignment due date with some section due dates set' do
          # A section due date can be nil
          # That section then uses the main due_date
          @attributes['assignment']['section_due_dates_type'] = '1'
          due_date_attributes = {
            '0' => { 'section_id' => "#{@section1.id}",
                     'due_date'   => nil },
            '1' => { 'section_id' => "#{@section2.id}",
                     'due_date'   => '2011-10-29 00:00' }
          }
          @attributes['assignment']['section_due_dates_attributes'] =
            due_date_attributes

          post_as @admin, :create, @attributes

          new_assignment =
            Assignment.where(short_identifier: @short_identifier).first

          assert_not_nil new_assignment
          assert_equal true, new_assignment.section_due_dates_type
          assert_nil new_assignment.section_due_dates[0].due_date

          expected_date = new_assignment.section_due_dates[1].due_date
          actual_date   = Time.parse(due_date_attributes['1']['due_date'])
          assert_equal expected_date, actual_date

          assert redirect_to(action: 'edit', id: new_assignment)
        end
      end  # With some sections
    end #creating new assignment

    should 'be able to get a new assignment form with submission rules HTML present' do
      get_as @admin, :new
      assert_not_nil response.body.to_s.match('NoLateSubmissionRule')
      assert_not_nil response.body.to_s.match('GracePeriodSubmissionRule')
      assert_not_nil response.body.to_s.match('PenaltyDecayPeriodSubmissionRule')
      assert_not_nil response.body.to_s.match('PenaltyPeriodSubmissionRule')
    end

    should 'with REPOSITORY_EXTERNAL_SUBMITS_ONLY as false' do
      MarkusConfigurator.stubs(
        :markus_config_repository_external_submits_only?).returns(false)
      get_as @admin, :new
      assignment = assigns(:assignment)
      assert assignment.allow_web_submits
    end  # -- with REPOSITORY_EXTERNAL_SUBMITS_ONLY as false

    should 'with REPOSITORY_EXTERNAL_SUBMITS_ONLY as true' do
      MarkusConfigurator.stubs(
        :markus_config_repository_external_submits_only?).returns(true)
      get_as @admin, :new
      assignment = assigns(:assignment)
      assert !assignment.allow_web_submits
    end  # -- with REPOSITORY_EXTERNAL_SUBMITS_ONLY as true

    context 'with an assignment' do
      setup do
        @assignment = Assignment.make
      end

      should 'get edit form if not post' do
        get_as @admin,
              :edit,
              id: @assignment.id
        assert_response :success
        assert assigns :assignment
      end

      should 'be able to edit a new assignment form with submission rules HTML present' do
        get_as @admin,
              :edit,
              id: @assignment.id
        assert_not_nil response.body.to_s.match('NoLateSubmissionRule')
        assert_not_nil response.body.to_s.match('GracePeriodSubmissionRule')
        assert_not_nil response.body.to_s.match('PenaltyDecayPeriodSubmissionRule')
        assert_not_nil response.body.to_s.match('PenaltyPeriodSubmissionRule')
      end

      should 'bounced off from student interface' do
        get_as @admin,
               :student_interface,
               id: @assignment.id
        assert_response :missing
      end

      should 'edit basic paramaters' do
        put_as @admin,
                :update,
                id: @assignment.id,
                assignment: {
                  short_identifier: 'New SI',
                  description: 'New Description',
                  message: 'New Message',
                  due_date: 3.days.from_now,
                  submission_rule_attributes: {
                    type: @assignment.submission_rule.type.to_s,
                    id: @assignment.submission_rule.id
                  }
                }
        @assignment.reload
        assert_equal 'New SI', @assignment.short_identifier
        assert_equal 'New Description', @assignment.description
        assert_equal 'New Message', @assignment.message
        assert ((3.days.from_now - @assignment.due_date).abs < 5)
      end

      should 'not be able to edit with invalid assignment' do
        put_as @admin,
               :update,
               id: @assignment.id,
               assignment: {
                  short_identifier: '',
                  description: 'New Description',
                  message: 'New Message',
                  due_date: 3.days.from_now,
                  submission_rule_attributes: {
                    type: @assignment.submission_rule.type.to_s,
                    id: @assignment.submission_rule.id}}
        a = Assignment.find(@assignment.id)
        assert_equal @assignment.short_identifier, a.short_identifier
        assert_equal @assignment.description, a.description
        assert_equal @assignment.message, a.message
        assert_equal @assignment.due_date, a.due_date
        assert_not_nil assigns(:assignment)
        assert !assigns(:assignment).errors.empty?
      end

      should 'not be able to edit with invalid submission rules' do
        put_as @admin,
                :update,
                id: @assignment.id,
                assignment: {
                  short_identifier: 'New SI',
                  description: 'New Description',
                  message: 'New Message',
                  due_date: 3.days.from_now,
                  submission_rule_attributes: {
                    type: 'UnknownClass',
                    id: @assignment.submission_rule.id}}
        a = Assignment.find(@assignment.id)
        assert_equal @assignment.short_identifier, a.short_identifier
        assert_equal @assignment.description, a.description
        assert_equal @assignment.message, a.message
        assert_equal @assignment.due_date, a.due_date
        assert_equal @assignment.submission_rule.type.to_s,
                     a.submission_rule.type.to_s
        assert_not_nil assigns(:assignment)
        refute_empty assigns(:assignment).errors
      end

      should 'be able to add periods to submission rule class' do
        put_as @admin,
                :update,
                {id: @assignment.id,
                 assignment: {
                   short_identifier: 'New SI',
                   description: 'New Description',
                   message: 'New Message',
                   due_date: 3.days.from_now,
                   submission_rule_attributes: {
                     type: 'PenaltyPeriodSubmissionRule',
                     id: @assignment.submission_rule.id,
                     periods_attributes: [
                       {deduction: '10', hours: '24'},
                       {deduction: '20', hours: '24'}
                     ]}}}
        @assignment.reload
        assert_equal 'New SI', @assignment.short_identifier
        assert_equal 'New Description', @assignment.description
        assert_equal 'New Message', @assignment.message
        assert_equal 'PenaltyPeriodSubmissionRule',
                     @assignment.submission_rule.type.to_s
        assert_equal 2, @assignment.submission_rule.periods.length
        first_period = @assignment.submission_rule.periods.first
        last_period = @assignment.submission_rule.periods.last
        assert_equal 10, first_period.deduction
        assert_equal 24, first_period.hours
        assert_equal 20, last_period.deduction
        assert_equal 24, last_period.hours

        assert_not_nil assigns(:assignment)
        assert assigns(:assignment).errors.empty?
      end

      # Regression test for Github issue #568
      should 'receieve errors when providing invalid period attributes for a submission rule' do
        put_as @admin,
                :update,
                {id: @assignment.id,
                 assignment: {
                   submission_rule_attributes: {
                     type: 'PenaltyPeriodSubmissionRule',
                     periods_attributes: {
                        '1' => { hours: nil, deduction: nil} },
                     id: @assignment.submission_rule.id,
                     }}}

        @assignment.reload
        # note that a div with this id is only displayed when we have an error on a page
        assert_select 'div.error'
      end

      # Regression test for Github issue #568
      should 'be able to switch submission rule when editing an assignment' do
        # First make sure that the current submission rule is one with periods
        # which we can then switch to NoLateSubmissionRule via a put_as
        rule = GracePeriodSubmissionRule.make
        period = Period.make
        period.submission_rule = rule
        assert period.save
        assert rule.periods.length > 0
        @assignment = Assignment.make( submission_rule: rule )
        assert @assignment.submission_rule.is_a?(GracePeriodSubmissionRule)

        put_as @admin,
               :update,
               id: @assignment.id,
               assignment: {
                 submission_rule_attributes: {
                   type: 'NoLateSubmissionRule',
                   periods_attributes: {
                     '1' => { id: period.id, hours: 1 }
                   },
                   id: @assignment.submission_rule.id,
                 }
               }

        assert_response :redirect
        # no errors should have been produced
        assert_equal [], assigns(:assignment).errors[:base]

        @assignment.reload
        assert @assignment.submission_rule.is_a?(NoLateSubmissionRule)
        assert_equal [I18n.t('assignment.update_success')], flash[:success]
      end

      should 'be able to set instructor forms groups' do
        @assignment = Assignment.make( student_form_groups: true )
        assert @assignment.student_form_groups
        put_as @admin,
                :update,
                {id: @assignment.id,
                 assignment: {
                   description: 'New Description',
                   message: 'New Message',
                   due_date: 3.days.from_now,
                   student_form_groups: '0',
                   submission_rule_attributes: {
                     type: 'NoLateSubmissionRule',
                     id: @assignment.submission_rule.id}},
                   is_group_assignment: 'true'}

        a = Assignment.find(@assignment.id)
        assert_equal 'New Description', a.description
        assert_equal 'New Message', a.message
        assert_equal @assignment.submission_rule.type.to_s,
                     a.submission_rule.type.to_s
        assert !a.student_form_groups
        assert_not_nil assigns(:assignment)
        assert assigns(:assignment).errors.empty?
      end

      should 'be able to set students to form groups' do
        @assignment = Assignment.make( student_form_groups: false )
        assert !@assignment.student_form_groups
        put_as @admin,
                :update,
                { id: @assignment.id,
                  is_group_assignment: 'true',
                  assignment: {
                    student_form_groups: '1',
                    submission_rule_attributes: {
                      type: 'NoLateSubmissionRule',
                      id: @assignment.submission_rule.id
                    }
                  }
                }

        @assignment.reload
        assert_redirected_to edit_assignment_path(@assignment)
        assert_equal [I18n.t('assignment.update_success')],
               flash[:success]

        assert_not_nil assigns(:assignment)
        assert assigns(:assignment).errors.empty?
        assert @assignment.student_form_groups
      end

      should 'get assignments list' do
        submission_rule = NoLateSubmissionRule.make
        submission_rule.stubs(:can_collect_now?).returns(false)
        submission_rule.stubs(:assignment).returns(@assignment)
        Assignment.any_instance.stubs(:submission_rule).returns(submission_rule)
        get_as @admin, :index
        assert assigns(:assignments)
        assert_response :success
      end

      context 'with required files' do
        setup do
          @file_1 = AssignmentFile.make(assignment: @assignment)
          @file_2 = AssignmentFile.make(assignment: @assignment)
        end

        should 'be able to remove required files' do
          put_as @admin,
                  :update,
                  id: @assignment.id,
                  assignment: {
                      short_identifier: @assignment.short_identifier,
                      description: @assignment.description,
                      message: @assignment.message,
                      due_date: @assignment.due_date,
                      assignment_files_attributes: {
                        '1' => { id: @file_1.id,
                                filename: @file_1.filename,
                                _destroy: '0' },
                        '2' => { id: @file_2.id,
                                filename: @file_2.filename,
                                _destroy: '1' }},
                      submission_rule_attributes: {
                        type: @assignment.submission_rule.type.to_s,
                        id: @assignment.submission_rule.id}}
          @assignment.reload
          assert_equal 1, @assignment.assignment_files.count
          assert_equal @file_1, @assignment.assignment_files.first
        end
      end  # -- with required files

      should 'be able to add section due dates' do
        put_as @admin,
                  :update,
                  id: @assignment.id,
                  assignment: {
                    short_identifier: @assignment.short_identifier,
                    description: @assignment.description,
                    message: @assignment.message,
                    due_date: @assignment.due_date,
                    submission_rule_attributes: {
                      type: @assignment.submission_rule.type.to_s,
                      id: @assignment.submission_rule.id
                    },
                    section_due_dates_type: '1',
                    section_due_dates_attributes: {
                      '0' => { 'section_id' => '2', 'due_date' => '2011-10-27 00:00' },
                      '1' => { 'section_id' => '3', 'due_date' => '2011-10-27 00:00' }
                    }
                  }
        @assignment.reload
        assert_equal true, @assignment.section_due_dates_type
        assert_equal 2, @assignment.section_due_dates.size
      end

      should 'be able to remove section due dates after adding them' do
        put_as @admin,
                  :update,
                  id: @assignment.id,
                  assignment: {
                    short_identifier: @assignment.short_identifier,
                    description: @assignment.description,
                    message: @assignment.message,
                    due_date: @assignment.due_date,
                    submission_rule_attributes: {
                      type: @assignment.submission_rule.type.to_s,
                      id: @assignment.submission_rule.id
                    },
                    section_due_dates_type: '1',
                    section_due_dates_attributes: {
                      '0' => { 'section_id' => '2', 'due_date' => '2011-10-27 00:00' },
                      '1' => { 'section_id' => '3', 'due_date' => '2011-10-27 00:00' }
                    }
                  }
        put_as @admin,
          :update,
          id: @assignment.id,
          assignment: {
            short_identifier: @assignment.short_identifier,
            description: @assignment.description,
            message: @assignment.message,
            due_date: @assignment.due_date,
            submission_rule_attributes: {
              type: @assignment.submission_rule.type.to_s,
              id: @assignment.submission_rule.id
            },
            section_due_dates_type: '0',
            section_due_dates_attributes: {
              '0' => { 'section_id' => '2', 'due_date' => '2011-10-27 00:00' },
              '1' => { 'section_id' => '3', 'due_date' => '2011-10-27 00:00' }
            }
          }

        @assignment.reload
        assert_equal false, @assignment.section_due_dates_type
        assert_empty @assignment.section_due_dates
        assert_empty SectionDueDate.all
      end
    end  # -- with an assignment

    context 'with a hidden assignment' do
      setup do
        @assignment = Assignment.make(short_identifier: 'AHidden',is_hidden: true)
      end

      should 'be able to view it' do
        get_as @admin, :index
        assert @response.body.include?(@assignment.short_identifier)
      end
    end # -- with a hidden assignment

    context ', on :download_assignment_list,' do

      should 'be able to download a csv file' do
        get_as @admin, :download_assignment_list, file_format: 'csv'
        assert_response :success
        assert_equal 'text/csv', response.header['Content-Type']
      end

      should 'be able to download a yml file' do
        get_as @admin, :download_assignment_list, file_format: 'yml'
        assert_response :success
        assert_equal 'text/yml', response.header['Content-Type']
      end

      should 'not be able to download an xml file' do
        get_as @admin, :download_assignment_list, file_format: 'xml'
        assert_response :redirect
        assert set_flash.to(t(:incorrect_format))
      end
    end

    context ', on :upload_assignment_list,' do

      should 'be able to upload a csv file' do
        post_as @admin,
                :upload_assignment_list,
                assignment_list: fixture_file_upload('../files/new_assignments.csv'),
                file_format: 'csv'
        assert_response :redirect
        assert_redirected_to(controller: 'assignments', action: 'index')
        assert_equal flash[:success], [I18n.t('csv_valid_lines',
                                             valid_line_count: 2)]
        assert_equal flash[:error], nil
        test1 = Assignment.find_by_short_identifier('ATest1')
        assert_not_nil test1
        test2 = Assignment.find_by_short_identifier('ATest2')
        assert_not_nil test2
        assert_generates '/assignments/upload_assignment_list', controller: 'assignments', action: 'upload_assignment_list'
        assert_recognizes({controller: 'assignments', action: 'upload_assignment_list' },
                          {path: 'assignments/upload_assignment_list', method: :post})
      end

      should 'be able to upload a yml file' do
        post_as @admin,
                :upload_assignment_list,
                assignment_list: fixture_file_upload('../files/new_assignments.yml'),
                file_format: 'yml', encoding: 'UTF-8'
        assert_response :redirect
        assert_redirected_to(controller: 'assignments', action: 'index')
        assert_equal flash[:success], [I18n.t('assignment.create_success')]
        assert_equal flash[:error], nil
        test1 = Assignment.find_by_short_identifier('ATest3')
        assert_not_nil test1
        test2 = Assignment.find_by_short_identifier('ATest4')
        assert_not_nil test2
        assert_generates '/assignments/upload_assignment_list', controller: 'assignments', action: 'upload_assignment_list'
        assert_recognizes({controller: 'assignments', action: 'upload_assignment_list' },
                          {path: 'assignments/upload_assignment_list', method: :post})
      end

      should 'not be able to upload a file without require fields' do
        post_as @admin,
                :upload_assignment_list,
                assignment_list: fixture_file_upload('../files/new_assignments.yml'),
                file_format: 'csv'
        assert_response :redirect
        assert_redirected_to(controller: 'assignments', action: 'index')
        assert_equal flash[:success], nil
        assert_not_equal flash[:error], nil
        test1 = Assignment.find_by_short_identifier('ATest5')
        assert_nil test1
      end

      should 'gracefully handle a non csv file with a csv extension' do
        tempfile = fixture_file_upload('files/pdf_with_csv_extension.csv')
        post_as @admin,
                :upload_assignment_list,
                assignment_list: tempfile,
                file_format: 'csv',
                encoding: 'UTF-8'

        assert_response :redirect
        assert_equal flash[:error],
                     [I18n.t('csv.upload.non_text_file_with_csv_extension')]
      end
    end

  end  # -- an Admin

  context 'A grader' do
    setup do
      @grader = Ta.make
    end

    context 'with an assignment' do
      setup do
        @assignment = Assignment.make
      end

      should 'not be able to edit' do
          get_as @grader,
                 :edit,
                 id: @assignment.id
          assert_response :missing
      end

      should 'bounced from student interface' do
        get_as @grader,
               :student_interface,
               id: @assignment.id
        assert_response :missing
      end

      should 'gets assignment list on the graders' do
        submission_rule = NoLateSubmissionRule.make
        submission_rule.stubs(:can_collect_now?).returns(false)
        submission_rule.stubs(:assignment).returns(@assignment)
        Assignment.any_instance.stubs(:submission_rule).returns(submission_rule)
        get_as @grader, :index
        assert assigns(:assignments)
        assert_response :success
      end

    end  # -- with an Assignment

    context 'with a hidden assignment' do
      setup do
        @assignment = Assignment.make(short_identifier: 'AHidden',is_hidden: true)
      end

      should 'be able to view it' do
        get_as @grader, :index
        assert @response.body.include?(@assignment.short_identifier)
      end
    end # -- with a hidden assignment
  end  # -- with a Grader

  context 'A student' do
    setup do
      @student = Student.make
    end

    context 'with an assignment' do
      setup do
        @assignment = Assignment.make(group_min: 2)
      end

      should "get assignment's index" do
        get_as @student, :index
        assert assigns(:a_id_results)
        assert assigns(:assignments)
        assert_response :success
      end

      should 'not be able to edit assignment' do
        get_as @student, :edit, id: @assignment.id
        assert_response :missing
      end

      should 'be able to get the student interface' do
        get_as @student,
               :student_interface,
               id: @assignment.id
        assert assigns(:assignment)
        assert assigns(:pending_grouping).nil?
        assert_response :success
      end

      should 'be able to create a group' do
        post_as(@student, :creategroup, {id: @assignment.id})
        assert_redirected_to action: 'student_interface',
                             id: @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
      end

      should 'not be able to invite without a group' do
        students = [Student.make, Student.make]
        user_names = students.collect{
                          |student| student.user_name
                        }.join(', ')
        assert_raise RuntimeError do
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: user_names})
        end
      end

      should 'not be able to work alone' do
        post_as @student,
                :creategroup,
                {id: @assignment.id, workalone: 'true'}

        assert_redirected_to action: 'student_interface',
                             id: @assignment.id
        assert_equal I18n.t('create_group.fail.can_not_work_alone',
                            group_min: @assignment.group_min),
                     flash[:fail_notice]
        assert !@student.has_accepted_grouping_for?(@assignment.id)
      end

      context 'invited in several group' do
        setup do
          @grouping = Grouping.make(assignment: @assignment)
          StudentMembership.make(
              grouping: @grouping,
              user: @student,
              membership_status: StudentMembership::STATUSES[:pending])
          StudentMembership.make(
              grouping: @grouping,
              membership_status: StudentMembership::STATUSES[:inviter])

          g = Grouping.make(assignment: @assignment)
          StudentMembership.make(
              grouping: g,
              user: @student,
              membership_status: StudentMembership::STATUSES[:pending])
          StudentMembership.make(
              grouping: g,
              membership_status: StudentMembership::STATUSES[:inviter])

        end

        should 'be able to join a group' do
          post_as @student, :join_group, {id: @assignment.id,
                                          grouping_id: @grouping.id}
          assert @student.has_accepted_grouping_for?(@assignment.id),
                'should have accepted grouping for this assignment'
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
        end

        should 'see all the pending invitations' do
          get_as @student, :student_interface, id: @assignment.id
          assert_response :success
          assert assigns(:pending_grouping)
          assert_equal 2, assigns(:pending_grouping).length
        end

        should 'be able to decline an invitation' do
          post_as(@student,
                  :decline_invitation,
                  {id: @assignment.id,
                   grouping_id: @grouping.id} )
          assert !@student.has_accepted_grouping_for?(@assignment.id),
                 'should not have accepted groupings for this assignment'
        end
      end

      context ', inviter of a group' do
        setup do
          @grouping = Grouping.make(assignment: @assignment)
          StudentMembership.make(
              user: @student,
              grouping: @grouping,
              membership_status: StudentMembership::STATUSES[:inviter])
        end

        should 'be able to invite a student' do
          student = Student.make
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: student.user_name})
          assert_equal([I18n.t('invite_student.success')], flash[:success])
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
        end

        should "not be able to invite a student that doesn't exist" do
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: 'zhfbdjhzkyfg'})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal(I18n.t('invite_student.fail.dne',
                              user_name: 'zhfbdjhzkyfg'),
                       flash[:fail_notice].first)
        end

        should 'not be able to invite a hidden student' do
          student = Student.make(hidden: true)
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: student.user_name})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal(I18n.t('invite_student.fail.hidden',
                              user_name: student.user_name),
                       flash[:fail_notice].first)
        end

        should 'not be able to invite an already invited student' do
          sm = StudentMembership.make(grouping: @grouping)
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                  invite_member: sm.user.user_name})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal(I18n.t('invite_student.fail.already_pending',
                              user_name: sm.user.user_name),
                       flash[:fail_notice].first)
        end

        should 'be able to invite multiple students' do
          students = [Student.make, Student.make]
          user_names = students.collect{
                |student| student.user_name
              }.join(',')
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id, invite_member: user_names})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal 2, @grouping.pending_students.size
        end

        should 'be able to invite multiple students with malformed string' do
          students = [Student.make, Student.make]
          invalid_users = ['%(*&@#$(*#$EJDF',
                           'falsj asdlfkjasdl aslkdjasd,dasflk(*!@*@*@!!!',
                           'lkjsdlkfjsdfsdlkfjsfsdf']
          user_names = ((students.collect{
                          |student| student.user_name
                         }) + invalid_users).join(',')
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: user_names})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal 2, @grouping.pending_students.size
        end

        should 'be able to invite students with spacing' do
          students = [Student.make, Student.make]
          user_names = students.collect{
                          |student| student.user_name
                        }.join(' ,  ')
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: user_names})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal 2, @grouping.pending_students.size
        end

        should 'not be able to invite self to a group' do
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: @student.user_name})
          assert_equal(I18n.t('invite_student.fail.inviting_self'),
                       flash[:fail_notice].first)
        end

        should 'not be able to invite admins' do
          admin = Admin.make
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: admin.user_name})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal 0, @grouping.pending_students.size
          assert_equal(I18n.t('invite_student.fail.dne',
                              user_name: admin.user_name),
                      flash[:fail_notice].first)
        end

        should 'not be able to invite graders' do
          grader = Ta.make
          post_as(@student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: grader.user_name})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal 0, @grouping.pending_students.size
          assert_equal(I18n.t('invite_student.fail.dne',
                              user_name: grader.user_name),
                       flash[:fail_notice].first)
        end

        should 'not be able to create another group' do
          post_as(@student,
                  :creategroup,
                  {id: @assignment.id})
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal I18n.t('create_group.fail.already_have_a_group'),
                       flash[:fail_notice]
          assert @student.has_accepted_grouping_for?(@assignment.id)
          assert_equal @grouping,
                       @student.accepted_grouping_for(@assignment.id)
        end

        should 'be able to delete rejected membership' do
          sm = StudentMembership.make(
                  grouping: @grouping,
                  membership_status: StudentMembership::STATUSES[:pending])

          assert_nothing_raised do
            post_as(@student,
                    :delete_rejected,
                    {id: @assignment.id,
                     membership: sm.id})
          end

          assert_raise ActiveRecord::RecordNotFound do
            StudentMembership.find(sm.id)
          end
          assert_redirected_to controller: 'assignments',
                               action: 'student_interface',
                               id: @assignment.id
          assert_response :redirect
        end

        should 'be able to disinvite someone' do
          sm = StudentMembership.make(
                  grouping: @grouping,
                  membership_status: StudentMembership::STATUSES[:rejected])
          post_as @student,
                  :disinvite_member,
                  {id: @assignment.id,
                   membership: sm.id}

          assert_response :found
          assert_equal [I18n.t('student.member_disinvited')],
                       flash[:success]
          assert_equal 1,
                       @grouping.memberships.length
        end

        should 'be able to delete an not valid group ' do
          assert !@grouping.is_valid?
          post_as @student,
                  :deletegroup,
                  {id: @assignment.id, grouping_id: @grouping.id}

          assert_redirected_to action: 'student_interface',
                               id: @assignment.id

          assert_equal([I18n.t('assignment.group.deleted')], flash[:success])
          assert !@student.has_accepted_grouping_for?(@assignment.id)
        end

        context 'with pending invitations' do
          setup do
            @invited = Student.make
            sm = StudentMembership.make(
                  grouping: @grouping,
                  membership_status: StudentMembership::STATUSES[:pending],
                  user: @invited)

          end

          should 'not be able to invite someone already invited' do
            post_as @student,
                    :invite_member,
                    {id: @assignment.id,
                     invite_member: @invited.user_name}
            assert_redirected_to action: 'student_interface',
                                 id: @assignment.id
            assert flash[:fail_notice].include?(
                      I18n.t('invite_student.fail.already_pending',
                             user_name: @invited.user_name))
          end
        end  # -- with pending invitations

        context 'which is valid' do
          setup do
             sm = StudentMembership.make(
                grouping: @grouping,
                membership_status: StudentMembership::STATUSES[:accepted])
             sm = StudentMembership.make(
                grouping: @grouping,
                membership_status: StudentMembership::STATUSES[:accepted])

          end

          should 'not be able to delete the group' do
            assert @grouping.is_valid?
            post_as @student,
                    :deletegroup,
                    {id: @assignment.id,
                     grouping_id: @grouping.id}
            assert_redirected_to action: 'student_interface',
                                 id: @assignment.id
            assert_equal I18n.t('groups.cant_delete'), flash[:fail_notice]
            assert @student.has_accepted_grouping_for?(@assignment.id)

          end
        end

        context 'with a submission' do
          setup do
            submission = Submission.make(grouping: @grouping)
          end

          should 'not be able to delete a group' do
            post_as @student,
                    :deletegroup,
                    {id: @assignment.id}
            assert_equal I18n.t('groups.cant_delete_already_submitted'),
                        flash[:fail_notice]
            assert @student.has_accepted_grouping_for?(@assignment.id)
          end
        end  # -- with pending invitations
      end  # -- Inviter of a group

      context 'in a group' do
        setup do
          @grouping = Grouping.make(assignment: @assignment)
          @sm = StudentMembership.make(
                 grouping: @grouping,
                 membership_status: StudentMembership::STATUSES[:accepted],
                 user: @student)
        end

        should 'not be able to delete rejected membership' do
          assert_raise RuntimeError do
            post_as @student,
                    :delete_rejected,
                    id: @assignment.id,
                    membership: @sm.id
          end
          assert_nothing_raised do
            membership = StudentMembership.find(@sm.id)
          end
          assert !@sm.nil?
          assert_response :success
        end

        should 'not be able to delete group' do
          post_as @student,
                  :deletegroup, {id: @assignment.id}
          assert_equal I18n.t('groups.cant_delete'), flash[:fail_notice]
          assert @student.has_accepted_grouping_for?(@assignment.id)
        end
      end  # -- in a group
    end  # -- with an assignment

    context 'with an assignment with group = 1' do
      setup do
        @assignment = Assignment.make(group_min: 1)
      end

      should 'be able to work alone' do
        post_as @student,
                :creategroup,
                {id: @assignment.id,
                 workalone: 'true'}
        assert_redirected_to action: 'student_interface',
                             id: @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
        grouping = @student.accepted_grouping_for(@assignment.id)
        assert grouping.is_valid?
      end
    end  # -- with an assignment with group_min = 1

    context 'with an assignment where instructors creates groups' do
      setup do
        @assignment = Assignment.make(student_form_groups: false)
      end

      should 'not be able to allow to form groups' do
        post_as @student,
                :creategroup,
                {id: @assignment.id}

        assert_equal I18n.t('create_group.fail.not_allow_to_form_groups'),
                    flash[:fail_notice]
      end

      context 'with a group' do
        setup do
          @grouping = Grouping.make(assignment: @assignment)
          StudentMembership.make(
              grouping: @grouping,
              membership_status: StudentMembership::STATUSES[:accepted],
              user: @student)

        end

        should 'not be able to delete grouping' do
          post_as @student,
                  :deletegroup,
                  {id: @assignment.id,
                   grouping_id: @grouping.id}
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id
          assert_equal(I18n.t('groups.cant_delete'), flash[:fail_notice])
          assert @student.has_accepted_grouping_for?(@assignment.id)

        end
      end
    end  # -- with an assignment where instructors creates groups

    context 'with an assignment where students have to work alone' do
      setup do
        @assignment = Assignment.make(group_min: 1,
                                      group_max: 1)
      end

      should 'create group automatically' do
        get_as @student, :student_interface, id: @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
        assert_not_nil @student.accepted_grouping_for(@assignment.id)
        assert_equal @student,
                     @student.accepted_grouping_for(@assignment.id).inviter
        assert_redirected_to action: 'student_interface',
                             id: @assignment.id
      end
    end  # -- with an assignment where students have to work alone

    context 'with an assignment, with a past due date' do
      setup do
        @assignment = Assignment.make(due_date: 3.days.ago)
      end

      context 'inviter of a group' do
        setup do
          @grouping = Grouping.make(assignment: @assignment)
          sm = StudentMembership.make(
                 grouping: @grouping,
                 membership_status: StudentMembership::STATUSES[:inviter],
                 user: @student)
        end

        should 'not be able to invite' do
          student = Student.make
          post_as @student,
                  :invite_member,
                  {id: @assignment.id,
                  invite_member: student.user_name}
          assert_redirected_to action: 'student_interface',
                              id: @assignment.id
          assert_equal I18n.t('invite_student.fail.due_date_passed',
                              user_name: student.user_name),
                      flash[:fail_notice].first
        end
      end
    end  # -- with an assignment, with a past due date

    context 'with an assignmt, with past due date but collection in future' do
      setup do
        @assignment = Assignment.make(due_date: 1.days.ago)
        grace_period_submission_rule = GracePeriodSubmissionRule.new
        @assignment.replace_submission_rule(grace_period_submission_rule)
        @assignment.save
        Period.make(submission_rule_id: @assignment.submission_rule.id,
                    hours: 62)
      end

      should 'have the create group link available' do
        get_as @student,
               :student_interface,
               id: @assignment.id
        assert_not_nil (response.body =~ /<a[^>]*>#{I18n.t(:create)}<\/a>/)
      end

      should 'be able to create a group' do
        post_as @student, :creategroup, id: @assignment.id
        assert_redirected_to action: 'student_interface',
                             id: @assignment.id
        assert @student.has_accepted_grouping_for?(@assignment.id)
      end

      context 'with a grouping' do
        setup do
          @grouping = Grouping.make(assignment: @assignment)
          StudentMembership.make(
              grouping: @grouping,
              membership_status: StudentMembership::STATUSES[:inviter],
              user: @student)

        end

        should 'be able to invite a student' do
          student = Student.make
          post_as @student,
                  :invite_member,
                  {id: @assignment.id,
                   invite_member: student.user_name}
          assert_equal([I18n.t('invite_student.success')], flash[:success])
          assert_redirected_to action: 'student_interface',
                               id: @assignment.id

        end
      end
    end # -- with an assignmt, with past due date but collection in future'

    context 'with a hidden assignment' do
      setup do
        @assignment = Assignment.make(short_identifier: 'AHidden',is_hidden: true)
      end

      should 'not be able to view it' do
        get_as @student, :index
        assert !@response.body.include?(@assignment.short_identifier)
      end
    end
  end  # -- A student
end
