#!/usr/bin/env bash

set -eE -o functrace

# This script is a wrapper around git-shell that first checks if a user has permission
# to access a given git repository.
#
# This script should be called only by the ssh daemon's ForceCommand.
# When a user tries to access a git repository over ssh, this script checks that the username
# associated with the public key is authorized to access the requested repository. If so, it
# modifies the original git command to point to the correct location of the requested repository
# on disk and runs the original command through the git-shell. If the username is not authorized,
# it rejects the request.


# Write to a log file if the MARKUS_LOG_FILE environment variable is set.
# This function always returns 0 so that subsequent commands after
# && will always be executed.
write_log() {
  if [[ -n "${MARKUS_LOG_FILE}" ]]; then
    echo "$(date): ${1}" >> "${MARKUS_LOG_FILE}"
  fi
  return 0
}

# Log unexpected errors
failure() {
  write_log "UNEXPECTED ERROR: ${1}"
}

# Convert the MARKUS_REPO_LOC_PATTERN to an actual path that points to a repository on disk.
# This function replaces '(instance)' with the REQUESTED_INSTANCE variable and appends the
# REQUESTED_REPO_DIR variable to the end. In general REQUESTED_INSTANCE should be the same as
# the relative url root for a given MarkUs instance. REQUESTED_REPO_DIR is a specific
# repository in that instance.
#
# For example:
#  MARKUS_REPO_LOC_PATTERN='/some/path/(instance)/repos'
#  REQUESTED_INSTANCE=csc108
#  REQUESTED_REPO_DIR=group_123.git
#  echo $(updated_repo_path)  # /some/path/csc108/repos/group_123.git
updated_repo_path() {
  echo "${MARKUS_REPO_LOC_PATTERN//(instance)/${REQUESTED_INSTANCE}}/${REQUESTED_REPO_DIR}"
}

trap 'failure "$BASH_COMMAND"' ERR

# shellcheck disable=SC1090
source "${HOME}/.ssh/rc"

# The following environment variables must be set:
#
# LOGIN_USER: set in the authorized keys file generated by MarkUs (tells us which username is associated
#             with the public key trying to connect to git over ssh)
# GIT_SHELL: the location of the git-shell executable on disk, usually this is /usr/bin/git-shell
# MARKUS_REPO_LOC_PATTERN: a string containing '(instance)' and '(repository)'. See the docstring for the
#                          updated_repo_path function for details
#
# It is highly recommended that the GIT_SHELL, MARKUS_REPO_LOC_PATTERN, and MARKUS_LOG_FILE be variables
# sourced from the "${HOME}/.ssh/rc" file (see above). You may also hard-code them in this file directly
# if you wish or source them from another file. If you do either, you must modify this file accordingly.
[[ -z ${LOGIN_USER} ]] && write_log 'ERROR: LOGIN_USER not set' && exit 1
[[ -z ${GIT_SHELL} ]] && write_log 'ERROR: GIT_SHELL not set' && exit 1
[[ -z ${MARKUS_REPO_LOC_PATTERN} ]] && write_log 'ERROR: MARKUS_REPO_LOC_PATTERN not set' && exit 1

REQUESTED_REPO_PATH=$(echo "${SSH_ORIGINAL_COMMAND}" | rev | cut -f1 -d' ' | rev) # ex: /csc108/group_1.git'
REQUESTED_INSTANCE=$(basename "$(dirname "${REQUESTED_REPO_PATH}")") # ex: csc108
REQUESTED_REPO_DIR=$(basename "${REQUESTED_REPO_PATH}") # ex: group_1.git'
REQUESTED_REPO="${REQUESTED_REPO_DIR%.*}" # ex: group_1
UPDATED_REPO_PATH="$(updated_repo_path)" # ex: /some/path/csc108/repos/group_123.git
GIT_ACCESS_FILE="$(dirname "${UPDATED_REPO_PATH}")/.access" # ex: /some/path/csc108/repos/.access
SSH_UPDATED_COMMAND="$(echo "${SSH_ORIGINAL_COMMAND}" | rev | cut -f2- -d' ' | rev) '${UPDATED_REPO_PATH}" # ex: upload-pack '/some/path/csc108/repos/group_123.git'

# A string containing all repository names (without .git) that the user with username == LOGIN_USER is
# allowed to access according to the GIT_ACCESS_FILE.
AVAILABLE_REPOS=$(grep -P ",${LOGIN_USER}(?:,|\s*$)" "${GIT_ACCESS_FILE}" | cut -f1 -d,)

if grep -qP "^${REQUESTED_REPO}|\*$" <(echo "${AVAILABLE_REPOS}"); then
  # If the LOGIN_USER is permitted to access the requested repo, run the modified GIT_SHELL command and
  # replace any mention of UPDATED_REPO_PATH with REQUESTED_REPO_PATH from stderr. The result of stderr
  # here will be shown to the user so this is to ensure that the location of files on disk is not revealed.
  ${GIT_SHELL} -c "${SSH_UPDATED_COMMAND}" 2> >(sed "s:${UPDATED_REPO_PATH}:${REQUESTED_REPO_PATH}:g" >&2)
  GIT_STATUS=$?
  if [ "${GIT_STATUS}" -ne 0 ]; then
    write_log "ERROR: LOGIN_USER=${LOGIN_USER} cmd=${SSH_ORIGINAL_COMMAND} GIT_OUTPUT=${GIT_OUTPUT}"
  else
    write_log "SUCCESS: LOGIN_USER=${LOGIN_USER} cmd=${SSH_ORIGINAL_COMMAND}"
  fi
  exit "${GIT_STATUS}"
else
  write_log "PERMISSION DENIED: LOGIN_USER=${LOGIN_USER} cmd=${SSH_ORIGINAL_COMMAND}"
  exit 1
fi
