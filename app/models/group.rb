# Maintains group information for a given user on a specific assignment
class Group < ApplicationRecord

  after_create :set_repo_name, :check_repo_uniqueness, :build_repository

  has_many :groupings
  has_many :submissions, through: :groupings
  has_many :student_memberships, through: :groupings
  has_many :ta_memberships,
           class_name: 'TaMembership',
           through: :groupings
  has_many :assignments, through: :groupings
  has_many :split_pages

  validates :group_name, presence: true, exclusion: { in: Repository.get_class.reserved_locations }
  validates_uniqueness_of :group_name
  validates_length_of :group_name, maximum: 30

  # prefix used for autogenerated group_names
  AUTOGENERATED_PREFIX = 'group_'

  # Returns the repository name for this group
  def repository_name
    self.repo_name
  end

  # Returns an autogenerated name for the group using Group::AUTOGENERATED_PREFIX
  # This only works, after a barebone group record has been created in the database
  def get_autogenerated_group_name
    Group::AUTOGENERATED_PREFIX + self.id.to_s.rjust(4, '0')
  end

  def grouping_for_assignment(aid)
    groupings.where(assessment_id: aid).first
  end

  # Returns the URL for externally accessible repos
  def repository_external_access_url
    Rails.configuration.x.repository.url + '/' + repository_name
  end

  def repository_ssh_access_url
    "#{Rails.configuration.x.repository.ssh_url}/#{repository_name}.git"
  end

  def build_repository
    # create repositories if and only if we are admin
    return true unless Rails.configuration.x.repository.is_repository_admin

    # This might cause repository collision errors, because when the group
    # maximum for an assignment is set to be one, the student's username
    # will be used as the repository name. This will raise a RepositoryCollision
    # if an instructor uses a csv file with a student appearing as the only member of
    # two different groups (remember: uploading via csv purges old groupings).
    #
    # Because we use the group id as part of the repository name in all other cases,
    # a repo collision *should* never occur then.
    #
    # For more info about the exception
    # See 'self.create' of lib/repo/subversion_repository.rb.

    begin
      Repository.get_class.create(repo_path)
    rescue Repository::RepositoryCollision => e
      # log the collision
      errors.add(:base, self.repo_name)
      m_logger = MarkusLogger.instance
      m_logger.log("Creating group '#{self.group_name}' caused repository collision " +
                   "(Repository name was: '#{self.repo_name}'). Error message: '#{e.message}'",
                   MarkusLogger::ERROR)
      raise
    end
    true
  end

  def repo_path
    File.join(Rails.configuration.x.repository.storage, self.repository_name)
  end

  #Yields a repository object, if possible, and closes it after it is finished
  def access_repo(&block)
    Repository.get_class.access(repo_path, &block)
  end

  private

  # Set repository name after new group is created
  def set_repo_name
    # If repo_name has been set already, use this name instead
    # of the autogenerated name.
    if self.repo_name.nil?
      self.repo_name = get_autogenerated_group_name
    end
    self.save(validate: false)
  end

  # Checks if the repository that is about to be created already exists. Used in a
  # after_create callback to check if there will be a repo collision.
  #
  # This raises an error if there will be a repo collision so that the transaction will
  # rollback before the repo itself is actually created (in an after_create_commit callback).
  #
  # Note that this requires the repo_name to be set either explicitly or by calling set_repo_name
  # after the group has been created.
  def check_repo_uniqueness
    return true unless Repository.get_class.repository_exists? repo_path

    msg = I18n.t 'csv.repo_collision_warning', repo_name: self.repo_name, group_name: group_name
    errors.add(:base, msg)
    self.errors.add(:repo_name, msg)
    raise StandardError, msg
  end
end
